# ALGORITHM TEMPLATE

## ğŸ“Œ ì™„ì „íƒìƒ‰
* DFS (ì¬ê·€í•¨ìˆ˜)
  * ë°©ë¬¸í‘œì‹œ, ì¶œë ¥ or ì—°ì‚°, ë‹¤ë¥¸ ë…¸ë“œ ë°©ë¬¸
  * ì¢…ë£Œ ì¡°ê±´ í•„ìš” (ì˜ˆë¥¼ ë“¤ì–´ ì¢Œí‘œê³„ ë²—ì–´ë‚¨)
```python
def dfs(graph, v, visited):
  # ì¢…ë£Œ ì¡°ê±´ í•„ìš”
  visited[v] = True
  print(v, end = ' ')
  for i in graph[v]:
    if not visited[i]:
      dfs(graph, i, visited)
```

* BFS (í)
  * í ìƒì„±, ë°©ë¬¸í‘œì‹œ, íê°€ ë¹Œë•Œê¹Œì§€ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì›ì†Œë“¤ íì— ì‚½ì…
```python
def bfs(graph, start, visited):
  queue = deque([start])
  visited[start] = True
  
  while queue:
    v = queue.popleft()
    print(v, end = ' ')
    for i in graph[v]:
      if not visited[i]:
        queue.append(i)
        visited[i] = True
```

## ğŸ“Œ ì •ë ¬
```python
result = sorted(result, key = lambda x: x[1])
result.sort(key = lambda x : x[1], reverse = True)
```

## ğŸ“Œ ì´ì§„íƒìƒ‰
* í•¨ìˆ˜
```python
def binary_search(array, target, start, end):
  while start <= end:
    mid = (start + end) // 2
    if array[mid] == target:
      return mid
    elif array[mid] > target
      end = mid -1
    else:
      start = mid + 1
  return None
```

## ğŸ“Œ ìµœë‹¨ê²½ë¡œ
* ë‹¤ìµìŠ¤íŠ¸ë¼
  * íŠ¹ì •ë…¸ë“œ -> ëª¨ë“  ë…¸ë“œ
  * `ìŒì˜ ê°„ì„ ` ì—†ì„ë•Œ
  * Version 1
  ```python
  # version 1
  def get_smallest_node():
    min_value = INF
    index = 0
    for i in range(1, n+1):
      if distance[i] < min_value and not visited[i]:
        min_value = distance[i]
        index = i
    return index

  def dijkstra(start):
    distance[start] = 0
    visited[start] = True

    for j in graph[start]:
      distance[j[0]] =j[1]

    for i in range(n-1):
      now = get_smallest_node()
      visited[now] = True

      for j in graph[now]:
        cost = distance[now]+j[1]
        if cost <distance[j[0]]:
          distance[j[0]] = cost
  ```
  * Version 2
  ```python
  def dijkstra(start):
  q = []
  heapq.heappush(q, (0, start))
  distance[start]  = 0 

  while q:
    dist, now = heapq.heappop(q)
    if distance[now] < dist:
      continue
    for i in graph[now]:
      cost = dist + i[1]
      if cost <distance[i[0]]:
        distance[i[0]] = cost
        heapq.heappush(q, (cost, i[0]))
  ```
  
* í”Œë£¨ì´ë“œ ì›Œì…œ
```python
for k in range(1, n+1):
  for a in range(1, n+1):
    for b in range(1, n+1):
      graph[a][b] = min(graph[a][b], graph[a][k]+graph[k][b])
```

## ğŸ“Œ ê·¸ë˜í”„ ì´ë¡ 
* ì„œë¡œì†Œ
  * íŠ¹ì • ì›ì†Œê°€ ì†í•œ ì§‘í•© ì°¾ê¸° (ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°)
  ```python
  def find_parent (parent , x ) :
    if parent [x] != x:
        parent [x] = find_parent(parent, parent[x])
    return parent[x]
  ```
  * ì§‘í•© í•©ì¹˜ê¸°
  ```python
  def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
  ```
* í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜
```python
edge.sort()
for edge in edges:
    cost, a, b = edge
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost
```
* ìœ„ìƒì •ë ¬
```python
def topology_sort():
    result = []
    q = deque()
    
    for i in range(1, v+1):
        if indegree[i] == 0:
            q.append(i)
    
    while q:
        now = q.popleft()
        result.append(now)
        
        for i in graph[now]:
            indegree[i] -= 1
            if indegree[i] == 0:
                q.append(i)
```
